---
id: methods
title: メソッド
---


メソッドとは、1つ以上の動作を実行するコードのことです。 メソッドは、一つ以上のステートメントで構成されます。ステートメントとは、メソッドの1行のことで1つの命令を実行します。 ステートメントは単純な場合もあれば、複雑な場合もあります。 各ステートメントは常に 1行ですが最大 32,000文字まで使用することができます。

メソッドは最大 2GBのテキストまたは、32000行まで記述できます。

## メソッドタイプ

4D ランゲージにおいて、数種類のメソッドが存在します。 その呼び出し方によって、メソッドは区別されます:

| タイプ                      | 自動呼び出しのコンテキスト                                             | 引数の受け取り | 説明                                                                                               |
| ------------------------ | --------------------------------------------------------- | ------- | ------------------------------------------------------------------------------------------------ |
| **プロジェクトメソッド**           | 呼び出しに応じて ([プロジェクトメソッドの呼び出し](#calling-project-methods) 参照) | ◯       | 任意のアクションを実行するためのコードです。 作成されたプロジェクトメソッドは、そのプロジェクトのランゲージの一部となります。                                  |
| **オブジェクト (ウィジェット) メソッド** | メソッドが設定されたフォームオブジェクトに関連したイベント発生時に                         | ×       | フォームオブジェクト (ウィジェットとも呼びます) のプロパティです。                                                              |
| **フォームメソッド**             | メソッドが設定されたフォームに関連したイベント発生時に                               | ×       | フォームのプロパティです。 フォームメソッドを使用してデータとオブジェクトを管理することができます。ただし、これら目的には、オブジェクトメソッドを使用する方が通常は簡単であり、より効果的です。 |
| **トリガー** (別名 *テーブルメソッド*) | テーブルのレコード操作 (追加・削除・修正) の度に                                | ×       | テーブルのプロパティです。 トリガーは、データベースのレコードに対して「不正な」操作がおこなわれることを防ぎます。                                        |
| **データベースメソッド**           | 作業セッションのイベント発生時に                                          | ○ (既定)  | 4D には 16のデータベースメソッドがあります。 詳細はデータベースメソッドの項を参照ください。                                                |


> 4D ランゲージは **クラス関数** もサポートしています。クラス関数は、オブジェクトインスタンスのコンテキストにおいて呼び出されます。 クラス関数にはビルトインのものと (*例: * `collection.orderBy()` や `entity.save()`)、[開発者によって作成されるもの](classes.md#function)があります。


## プロジェクトメソッドの呼び出し

その実行方法や使用方法に応じて、プロジェクトメソッドは次のような役割を果たします:

- サブルーチン
- オブジェクトフォーミュラ
- メニューメソッド
- プロセスメソッド
- イベントまたはエラー処理メソッド

### サブルーチン

サブルーチンは、処理の下請け的なプロジェクトメソッドです。 他のメソッドから呼ばれて、要求された処理を実行します。 関数は、呼び出し元のメソッドに値を返すサブルーチンのことです。

プロジェクトメソッドを作成すると、それは同データベースのランゲージの一部となります。 プロジェクトメソッドは、4Dのビルトインコマンドと同様に、ほかのメソッド (プロジェクトメソッドやオブジェクトメソッド) から呼び出すことができます。 このように使用されるプロジェクトメソッドをサブルーチンと呼びます。

サブルーチンは、以下のような目的で使います:

- 重複コードの削減
- メソッドの役割の明確化
- メソッド改変の容易化
- コードのモジュール化

たとえば、顧客データベースがあるとします。 プロジェクトをカスタマイズしていくうちに、顧客を検索してレコードを修正するという一連の作業を繰り返しおこなっていることに気づいたとします。 そのコーディングは以下のようになっています:

```4d
  // 顧客を検索します
 QUERY BY EXAMPLE([Customers])
  // 入力フォームを選択します
 FORM SET INPUT([Customers];"Data Entry")
  // 顧客レコードを修正します
 MODIFY RECORD([Customers])
```

サブルーチンを使用しなければ、顧客レコード修正のたびにコードを作成しなければなりません。 プロジェクトの 10箇所で同じ処理が必要であれば、同じコーディングを 10回も書かねばなりません。 サブルーチンを使用すれば 1回コーディングするだけですみます。 これがコーディングの重複を減らすというサブルーチンの第一の利点です。

先ほど説明したコードが `MODIFY_CUSTOMER` と呼ばれるメソッドであるとすれば、他のメソッド内でそのメソッド名を使うことで実行できます。 たとえば、顧客のレコードを修正し、それからレコードをプリントするために、以下のようなメソッドを書くことができます:

```4d
 MODIFY_CUSTOMER
 PRINT SELECTION([Customers])
```

この機能はメソッドを劇的にに簡素化します。 さきほどの例で言えば、`MODIFY_CUSTOMER` メソッドがどのように動作するかは知る必要がなく、何をおこなうかだけ知っていればよいのです。 これはメソッドをサブルーチン化することの2番目の理由、役割の明確化です。 このように、作成されたメソッドは 4Dランゲージを拡張します。

このプロジェクトの例で顧客の検索方法を変える場合、10箇所ではなく、たった1つのメソッドを変更するだけですみます。 これがサブルーチンを使うもう一つの理由、改変の容易化です。

また、サブルーチンの利用はコードをモジュール化します。 これはコードをモジュール (サブルーチン) に分割することを意味し、それぞれは論理的な処理を実行します。 小切手振り出し口座のプロジェクトから、以下のコードを見てみましょう:

```4d
 FIND_CLEARED_CHECKS // 決済された小切手の検索
 RECONCILE_ACCOUNT // 口座の照合
 PRINT_CHECK_BOOK_REPORT // レポートの印刷
```

プロジェクトの詳細を知らない人でも、このプログラムが何をしているかはわかります。 各サブルーチンの処理手順を知る必要はありません。 各サブルーチンは長く、複雑な処理で構成されていることもありますが、それらが何を実行するのかだけを知っていれば十分なのです。 プログラムを論理的な処理単位やモジュールにできるだけ分割することをお勧めします。


### オブジェクトフォーミュラ

プロジェクトメソッドは、**フォーミュラ** オブジェクトにカプセル化して、オブジェクトから呼び出すことができます。

`Formula` または `Formula from string` コマンドを使用すると、オブジェクトプロパティに格納可能な、ネイティブなフォーミュラオブジェクトを作成することができます: つまり、カスタムなオブジェクトメソッドを実装することが可能です。

オブジェクトプロパティに保存されているメソッドを実行するには、プロパティ名のあとに **( )** をつけます。 たとえば:

```4d
// myAlert プロジェクトメソッド
ALERT("Hello world!")
```

この `myAlert` プロジェクトメソッドを任意のオブジェクトに格納し、呼び出すことができます:

```4d
C_OBJECT($o)
$o:=New object("custom_Alert";Formula(myAlert))
$o.custom_Alert() // "Hello world!" と表示します
```

大カッコを使用したシンタックスもサポートされます:

```4d
$o["custom_Alert"]() // "Hello world!" と表示します
```

4D プロジェクトメソッドのように、$1, $2, .... を使用して呼び出すことで、フォーミュラに [引数を渡す](Concepts/parameters.md) こともできます:

```4d
//fullName メソッド
C_TEXT($0;$1;$2)
$0:=$1+" "+$2
```

`fullName` メソッドをオブジェクトに格納し、呼び出します:

```4d
C_OBJECT($o)
$o:=New object("full_name";Formula(fullName))
$result:=$o.full_name("John";"Smith") 
//$result = "John Smith"
// $result:=fullName("param1";"param2") と同義です
```

`This` 関数と組み合わせることで、オブジェクトメソッドを利用した汎用的なコードを書くことができます。 たとえば:

```4d
//fullName2 メソッド
C_TEXT($0)
$0:=This.firstName+" "+This.lastName
```

このメソッドをオブジェクトに格納すると、オブジェクトの新しい計算属性のように使えます:

```4d
C_OBJECT($o)
$o:=New object("firstName";"Jim";"lastName";"Wesson")
$o.fullName:=Formula(fullName2) // メソッドをオブジェクトに追加します

$result:=$o.fullName() 
//$result = "Jim Wesson"
```



たとえ引数を受け取らなかったとしても、オブジェクトメソッドを実行するためにはカッコ () をつけて呼び出す必要があるという点に注意してください。 オブジェクトプロパティのみを呼び出した場合、フォーミュラへの新しい参照が返されます (そしてフォーミュラは実行はされません):

```4d
$o:=$f.message // $o にはフォーミュラオブジェクトが返されます
```

### メニューメソッド
メニューメソッドは、カスタムメニューから呼び出されるプロジェクトメソッドです。 メニューエディターまたは "メニュー" テーマのコマンドを使用して、メニューにメソッドを割り当てます。 メニューが選択されると、それに対応するメニューメソッドが実行されます。 特定の処理を実行するメニューメソッドを割り当てたカスタムメニューを作成することで、デスクトップアプリケーションのユーザーインターフェースをカスタマイズすることができます。

メニューメソッドにより、単一または複数の処理を実行することができます。 たとえば、データ入力のメニューに、以下の2つの処理を実行するメソッドを割り当てられます。まず適切な入力フォームを表示し、次にユーザーがキャンセルするまでの間 `ADD RECORD` コマンドによるデータ入力を繰り返します。

連続した処理の自動化は、プログラミング言語の強力な機能の 1つです。 カスタムメニューを使用することで処理を自動化することができ、アプリケーションのユーザーにより多くのガイダンスを提供することができます。


### プロセスメソッド

**プロセスメソッド** とは、プロセスの開始時に呼び出されるプロジェクトメソッドのことです。 ワーカープロセスの場合を除いて、プロセスはプロセスメソッドが実行されている間だけ存続します。 メニューに属するメニューメソッドのプロパティとして *新規プロセス開始* をチェックしている場合、そのメニューメソッドは新規プロセスのプロセスメソッドでもあります。

### イベント・エラー処理メソッド
**イベント処理メソッド** は、イベントを処理するプロセスメソッドとして、分離されたプロセス内で実行されます。 通常、開発者はイベント管理の大部分を 4Dに任せます。 たとえば、データ入力中にキーストロークやクリックを検出した 4Dは、正しいオブジェクトとフォームメソッドを呼び出します。このため開発者は、これらのメソッド内でイベントに対し適切に応答できるのです。 詳細については `ON EVENT CALL` コマンドの説明を参照してください。

**エラー処理メソッド** は、割り込みを実行するプロジェクトメソッドです。 エラーや例外が起こる度に、エラー処理メソッドは自身がインストールされたプロセス内で実行されます。 詳細については `ON ERR CALL` コマンドの説明を参照してください。

## プロジェクトメソッドの再帰呼び出し

プロジェクトメソッドは、自分自身を呼び出すことができます。 たとえば:

- メソッドAがメソッドBを呼び出し、メソッドBはメソッドAを呼び出します。
- メソッドAは自身を呼び出すことができます。

これは再帰呼び出しと呼ばれています。 4D ランゲージは再帰呼び出しを完全にサポートしています。

次に例を示します。 以下のフィールドから成る `[Friends and Relatives]` テーブルがあります:
- `[Friends and Relatives]Name`
- `[Friends and Relatives]ChildrensName`

この例題では、フィールドの値は重複しない、つまり同じ名前の人間はいないとします。 名前を指定することで、以下のような文を作成します: “A friend of mine, John who is the child of Paul who is the child of Jane who is the child of Robert who is the child of Eleanor, does this for a living!”:

1. この文を以下のように作成できます:

```4d
 $vsName:=Request("Enter the name:";"John")
 If(OK=1)
    QUERY([Friends and Relatives];[Friends and Relatives]Name=$vsName)
    If(Records in selection([Friends and Relatives])>0)
       $vtTheWholeStory:="A friend of mine, "+$vsName
       Repeat
          QUERY([Friends and Relatives];[Friends and Relatives]ChildrensName=$vsName)
          $vlQueryResult:=Records in selection([Friends and Relatives])
          If($vlQueryResult>0)
             $vtTheWholeStory:=$vtTheWholeStory+" who is the child of "+[Friends and Relatives]Name
             $vsName:=[Friends and Relatives]Name
          End if
       Until($vlQueryResult=0)
       $vtTheWholeStory:=$vtTheWholeStory+", does this for a living!"
       ALERT($vtTheWholeStory)
    End if
 End if
```

2. 以下の方法でも作成できます:

```4d
 $vsName:=Request("Enter the name:";"John")
 If(OK=1)
    QUERY([Friends and Relatives];[Friends and Relatives]Name=$vsName)
    If(Records in selection([Friends and Relatives])>0)
       ALERT("A friend of mine, "+Genealogy of($vsName)+", does this for a living!")
    End if
 End if
```

再帰関数 `Genealogy of` は以下の通りです:

```4d
  ` Genealogy of プロジェクトメソッド
  ` Genealogy of ( String ) -> Text
  ` Genealogy of ( Name ) -> Part of sentence

 $0:=$1
 QUERY([Friends and Relatives];[Friends and Relatives]ChildrensName=$1)
 If(Records in selection([Friends and Relatives])>0)
    $0:=$0+" who is the child of "+Genealogy of([Friends and Relatives]Name)
 End if
```

`Genealogy of` メソッドが自分自身を呼び出していることに注目してください。

最初に挙げた方法は **反復性のアルゴリズム** です。 2番目に挙げた方法は **再帰呼び出しのアルゴリズム** です。

前述の例題のようなコードを実装する場合、反復性や再帰呼び出しを使用してメソッドを書くことができるということに留意してください。 再帰呼び出しは一般的に、より明瞭で読みやすく、維持しやすいコードを提供します。ただし、この使用は必須ではありません。

4D内での再帰呼び出しの代表的な使用方法は以下のとおりです:

- 例題と同じく、互いに関連するテーブル内でのレコードの取り扱い。
- `FOLDER LIST` と `DOCUMENT LIST` コマンドを使用して、ディスク上にあるドキュメントとフォルダーをブラウズする。 フォルダーにはフォルダーとドキュメントが含まれており、サブフォルダーはまたフォルダーとドキュメントを含むことができます。

**重要:** 再帰呼び出しは、必ずある時点で終了する必要があります。 たとえば、`Genealogy of` メソッドが自身の呼び出しを止めるのは、クエリがレコードを返さないときです。 この条件のテストをしないと、メソッドは際限なく自身を呼び出します。 (メソッド内で使用される引数やローカル変数の蓄積を含む) 再帰呼び出しによって容量が一杯になると、最終的に 4Dは “スタックがいっぱいです” エラーを返します 。

## プロジェクトメソッドプロパティ

プロジェクトメソッドを作成した後、その名称やプロパティを変更することができます。 プロジェクトメソッドのプロパティは主に、実行アクセスやセキュリティ条件 (ユーザー、統合されたサーバーやサービスからのアクセスの可否) に加えて、実行モードに関する設定が含まれます。 

他のタイプのメソッドには専用のプロパティがありません。 これらのメソッドのプロパティは、それらが関連付けられているオブジェクトに基づいて決定されます。

プロジェクトメソッドのプロパティを変更するには:

1.  [コードエディター](../code-editor/interface.md) にて:
* **メソッド** メニューから **メソッドプロパティ...** を選択します。
* エクスプローラーの **メソッド** ページでプロジェクトメソッドを選択し、コンテキストメニューまたはオプションメニューから **メソッドプロパティ...** を選択します。 **メソッドプロパティ** ダイアログボックスが表示されます。

**注:** 一回の処理で複数のプロジェクトメソッドの属性を設定するために、属性の一括設定を使用できます ([属性の一括設定](#属性の一括設定) 参照)。

#### 名称  

**メソッドプロパティ** ウィンドウの **名称** エリア、またはエクスプローラーでプロジェクトメソッド名を変更できます。

新しい名称は 4D の命名規則に沿っていなければなりません ([識別子](../Concepts/identifiers.md) 参照)。 同じ名称のメソッドが既に存在する場合、4D はその旨を知らせるメッセージを表示します。 名称変更後、4D メソッドリストをソートします。 

**警告:** プロジェクトメソッドの名前を変更すると、そのメソッドを旧名称で呼び出している他のメソッドやフォーミュラなど、アプリケーションの機能が無効になるリスクがあります。 このため、この変更を手動ではなく、[名称変更](https://doc.4d.com/4Dv19R5/4D/19-R5/Renaming.300-5851389.ja.html) で説明されているプロジェクトメソッド名の名称変更機能によりおこなうことが強く推奨されます。 この機能を使用すれば、デザイン環境における当該メソッドの呼び出し箇所がすべて自動的に更新されます (ただし EXECUTE METHOD など、文字列としてメソッド名が参照されている個所を除きます)。

4D Server の場合、名称変更は変更終了後にサーバーに反映されます。 複数のユーザーが同時に名称を変更しようとすると、最後におこなわれた名称変更が適用されます。 メソッドのオーナーを指定すれば特定のユーザー以外はメソッド名を変更できないようにできます。

**注:** データベースメソッドの名称を変更することはできません。 オブジェクトに紐付いたトリガー、フォームメソッド、オブジェクトメソッドも同様です。これらは関連先のオブジェクトにより名称を決定されます。 

#### 属性  

属性を使用して、プロジェクトメソッドがどのコンテキストにおいて利用可能かを指定できます。 エクスプローラーを使用して複数のプロジェクトメソッドに対し、属性を一括して設定することもできます (後述参照)。

##### 非表示  

ユーザーに対し、**実行** メニューの **メソッド...** から特定のメソッドを実行させたくない場合、このオプションを選択すればそのメソッドを非表示にできます。 非表示のメソッドはメソッド実行ダイアログボックスに表示されなくなります ([メソッド実行ダイアログボックスから実行](#メソッド実行ダイアログボックスから実行) 参照)。 

プロジェクトメソッドを非表示にしても、データベースプログラマーはそれを使用することができます。 メソッドを非表示にしてもエクスプローラーのメソッドページやコードエディターのメソッドリストには表示されます。

##### コンポーネントとホストプロジェクト間で共有   

この属性は、コンポーネントのフレームワークで使用されます。 このオプションが選択されていると、アプリケーションがホストデータベースとして実行されている場合、そのメソッドがコンポーネントから実行可能になります。 また、アプリケーションがコンポーネントとして実行されている場合、そのメソッドはホストデータベースから実行可能となります。 

コンポーネントについては [4Dコンポーネントの開発とインストール](../Extensions/develop-components.md) を参照ください。

##### サーバー上で実行  

この属性は、クライアント/サーバーモードの 4Dアプリケーションでのみ考慮されます。 このオプションが選択されていると、そのプロジェクトメソッドは呼び出し方に関わらず常にサーバー上で実行されます。 

このオプションに関する詳細は 4D Serverリファレンスマニュアルの [サーバー上で実行属性](https://doc.4d.com/4Dv19R5/4D/19-R5/Execute-on-Server-attribute.300-5878333.ja.html) を参照ください。

#### 実行モード  

このオプションを使用すると、メソッドのプリエンプティブ実行が可能であることを宣言できます。 デフォルトでは、4D はアプリケーション内のプロジェクトメソッドをすべてコオペラティブモードで実行します。 

プリエンプティブモード機能を利用したい場合、プリエンプティブモードで実行したいメソッドをすべて明示的に宣言する必要があります。 その後、コンパイラーがこれらのメソッドが実際にスレッドセーフであるかどうかをチェックします。

**注:** プリエンプティブモードでの実行は、コンパイルモードでのみ利用可能です。 詳細については、[プリエンプティブ4Dプロセス](https://doc.4d.com/4Dv19R5/4D/19-R5/Preemptive-4D-processes.300-5830919.ja.html) の章を参照ください。

以下のオプションが提供されています:

-   **プリエンプティブプロセスで実行可能**: このオプションをチェックすると、当該メソッドはプリエンプティブプロセスでの実行が可能であり、可能な場合にはプリエンプティブモードで実行するべきと宣言します。 メソッドの "preemptive" プロパティは "capable" に設定されます。

このオプションがチェックされている場合、4Dコンパイラーはメソッドが実際にプリエンプティブモードで実行可能かどうかを検証し、そうでない場合 (たとえば、プリエンプティブモードで実行不可能なコマンドやメソッドを直接的あるいは間接的に呼び出している場合など) にはエラーを返します。なお、コールチェーンはすべて解析されますが、最初のサブレベルに対してのみエラーが報告されます。 エラーの場合には、メソッドを編集してスレッドセーフにするか、あるいは別のオプションを選択します。

メソッドのプリエンプティブ性が証明されると、内部で "thread safe" というタグ付けがされ、すべての要件が満たされればプリエンプティブモードで実行されます。 このプロパティはプリエンプティブモードの資格を定義しますが、メソッドが実際にプリエンプティブモードで実行されることを保証するものではありません。プリエンプティブ実行モードは特定のコンテキストを必要とするからです ([プロセスがプリエンプティブに実行される条件とは？](https://doc.4d.com/4Dv19R5/4D/19-R5/Preemptive-4D-processes.300-5830919.ja.html#2822148) を参照ください)。

-   **プリエンプティブプロセスでは実行不可**: このオプションをチェックすると、当該メソッドはプリエンプティブモードでの実行は不可能であると宣言し、以前の 4D のバージョンと同様に常にコオペラティブモードで実行されます。 メソッドの "preemptive" プロパティは "incapable" に設定されます。

このオプションがチェックされている場合、4Dコンパイラーはメソッドがプリエンプティブ実行可能かどうかを検証しません。メソッドは内部で自動的に "thread unsafe" とタグ付けされます (たとえ、理論的にはスレッドセーフであってもです)。 ランタイムで呼び出された場合、このメソッドは同じスレッド内の他のメソッドを "汚染" し、他のメソッドがスレッドセーフであったとしても、スレッドはコオペラティブモードでの実行を強制されます。

-   **特に設定しない** (デフォルト): このオプションをチェックすると、当該メソッドについてはプリエンプティブプロパティを管理しないことを宣言します。 メソッドの "preemptive" プロパティは "indifferent" に設定されます。

このオプションがチェックされているとき、4Dコンパイラーはメソッドのプリエンプティブ性を評価し、内部的に "thread safe" あるいは "thread unsafe" のタグ付けをします。 プリエンプティブ実行に関するエラーは報告されません。 メソッドがスレッドセーフと評価されていれば、ランタイムでプリエンプティブコンテキストから呼び出された場合にはプリエンプティブスレッド実行を妨げません。 逆に、メソッドがスレッドアンセーフであると評価された場合には、ランタイムで呼び出された場合に、プリエンプティブなスレッド実行を不可能にします。

このオプションを使用した場合、内部でのスレッドセーフ評価に関わらず、最初の親メソッドとしてメソッドが 4D から直接呼び出された場合 (たとえば [New process](https://doc.4d.com/4Dv19R5/4D/19-R5/New-process.301-5830903.ja.html) コマンドから呼び出された場合など)、メソッドは常にコオペラティブモードで実行されます。 内部で "thread-safe" とタグ付けされている場合、そのタグはコールチェーン内で他のメソッドから呼び出された場合に限り考慮されます。

***特殊なケース*:** メソッドの **コンポーネントとホストプロジェクト間で共有** プロパティがチェックされている場合 ([プロジェクトメソッドプロパティ](https://doc.4d.com/4Dv19R5/4D/19-R5/Project-method-properties.300-5851552.ja.html) 参照)、**特に設定しない** オプションを選択するとメソッドは自動的にスレッドアンセーフであるとタグ付けされます。 共有コンポーネントメソッドをスレッドセーフにしたい場合には、**プリエンプティブプロセスで実行可能** オプションを明示的に選択する必要があります。 

#### 公開オプション  

公開オプション属性は、当該メソッドの呼び出しが明示的に許可された外部サービスを指定します。

##### Webサービス  

この属性を使用して、SOAPリクエストでアクセス可能な Webサービスとして当該メソッドを公開することができます。 詳細は [Web サービスの公開と使用](https://doc.4d.com/4Dv19R5/4D/19-R5/Publication-and-use-of-Web-Services.200-5851321.ja.html) を参照ください。 このオプションを選択すると、**WSDL を公開** オプションを選択できるようになります。

エクスプローラーでは、Webサービスとして提供されるプロジェクトメソッドには専用のアイコンが表示されます ![](https://doc.4d.com/4Dv19R5/picture/440512/pict440512.fr.png)。

**注:** メソッド名が XML の命名規則に準拠しない文字 (たとえばスペース) を含む場合、そのメソッドは Webサービスとして公開できません。 この場合、設定は保存できません。

##### WSDL を公開  

この属性は "Webサービス" 属性が設定されている場合にのみ利用可能です。 この属性を設定すると、当該メソッドが 4Dアプリケーションの WSDLに 含まれます。 詳細については [WSDL ファイルを生成する](https://doc.4d.com/4Dv19R5/4D/19-R5/Publishing-a-Web-Service-with-4D.300-5851558.ja.html#502689) を参照ください。 

エクスプローラーでは、Webサービスとして提供され、WSDLで公開されたプロジェクトメソッドには専用のアイコンが表示されます ![](https://doc.4d.com/4Dv19R5/picture/440526/pict440526.fr.png)。 

##### 4D タグと URL(4DACTION...)  

このオプションは、4D Webサーバーのセキュリティを強化するために使用されます。このオプションが選択されていない場合、4DACTION URL を使用した HTTPリクエスト、および4DSCRIPT、4DTEXT、4DHTML タグ (さらには以前の 4DVAR や 4DHTMLVAR タグ) から当該メソッドを直接呼び出すことができません。 詳細については 4D *ランゲージリファレンス* マニュアルの [URLとフォームアクション](https://doc.4d.com/4Dv19R5/4D/14-R2/URLs-and-Form-Actions.300-1342176.ja.html) および [4D 変換タグ](Tags/tags.md) を参照ください。

エクスプローラーでは、この属性が設定されたプロジェクトメソッドには専用のアイコンが表示されます ![](https://doc.4d.com/4Dv19R5/picture/440496/pict440496.fr.png)。

セキュリティのため、このオプションはデフォルトで選択されていません。 Web機能から直接呼び出されるメソッドには、このオプションを明示的に選択しなければなりません。

##### SQL  

この属性が選択されていると、当該プロジェクトメソッドは 4D の SQLエンジンから実行可能となります。 デフォルトでは選択されておらず、明示的に許可されない限り 4Dメソッドは保護されており、4D SQLエンジンから呼び出すことはできません。 

このプロパティはすべての内部および外部SQLクエリ (ODBCドライバー経由、[Begin SQL](https://doc.4d.com/4Dv19R5/4D/19-R5/Begin-SQL.301-5830074.ja.html)/[End SQL](https://doc.4d.com/4Dv19R5/4D/19-R5/End-SQL.301-5830073.ja.html) タグ内の SQLコード、または [QUERY BY SQL](https://doc.4d.com/4Dv19R5/4D/19-R5/QUERY-BY-SQL.301-5830079.ja.html) からの呼び出し) に適用されます。

**注:**

-   メソッドに "SQL" 属性が設定されていても、メソッドの実行時にはデータベース設定およびメソッドプロパティに設定されたアクセス権が考慮されます。
-   ODBC の **SQLProcedure** 関数は "SQL" 属性が設定されているプロジェクトメソッド名のみを返します。

詳細については、SQLマニュアルの [4Dと4D SQLエンジン統合の原則](https://doc.4d.com/4Dv19R5/4D/19-R5/4D-SQL-engine-implementation.300-5871873.ja.html) を参照ください。

##### REST サーバー  

*このオプションは、従来のカレントレコードおよびカレントセレクションの概念に依存しており、廃止予定となっています。 RESTアクセスには、[ORDAデータモデルクラス関数](https://developer.4d.com/docs/en/REST/classFunctions.html) を使用することが推奨されます。 *

#### 属性の一括設定  

"メソッド属性" ダイアログボックスを使用して、一回の操作で複数のプロジェクトメソッドに対して属性 (非表示、Webサービスで公開、等) を設定することができます。 この機能は、多数のプロジェクトメソッドの属性を一括して変更する場合に便利です。 また、開発の段階で、類似のメソッド群に共通の属性を素早く適用するのに使用することもできます。

メソッド属性の一括設定をおこなうには:

1.  エクスプローラーの [メソッドページ](https://doc.4d.com/4Dv19R5/4D/19-R5/Methods-Page.300-5851337.ja.html) からオプションメニューを展開し、**属性の一括設定...** コマンドを選択します。 "メソッド属性" ダイアログボックスが表示されます:
2.  "一致するメソッド名" エリアに属性を一括設定するメソッドを指定するための名前条件を入力します。 入力した文字列を使用してメソッド名が検索されます。 "@" をワイルドカード文字として使用し、メソッドグループを選択できます:
   -   前方一致で検索するには、文字列の最後に "@" を加えます。 例: web@
    -   含む検索をするには、文字列の中に "@" を加えます。 例: web@write
    -   後方一致で検索するには、文字列の先頭に "@" を加えます。 例: @write
    -   すべてのメソッドを選択するには "@" のみを入力します。\<br /> **注:**
        -   文字の大小は区別されません。
        -   "@" は文字列内で複数回使用できます (例: dtro_@web@pro.@)
3.  "更新する属性" エリアでは、ドロップダウンリストから更新対象の属性を選択し、**True** または **False** ラジオボタンを選択します。 **注:** "WSDL で公開する" 属性を True に設定した場合、"Webサービスとして公開" 属性が True に設定されたメソッドにのみ適用されます。
4.  **適用** をクリックします。 検索条件に合致するプロジェクトメソッドに対し、属性の変更は即座に反映されます。

## メソッドの実行

アプリケーションに定義されたプロジェクトメソッドは通常、アプリケーションの使用中にボタンやメニュー、他のメソッドなどから自動的に呼び出されます。 データベースメソッドについては、アプリケーションで発生する特定のイベントに反応して実行されます。 

しかし、テストやデバッグの目的で、プロジェクトメソッドや特定のデータベースメソッドをデザインモードで実行することができます。 この場合、メソッドを新規プロセスで実行するか、または直接デバッグモードで一行ごと実行できます。

さらに 4D Server 環境においては、サーバー上でメソッドを実行するか、クライアント上で実行するかを指定できます。 メソッド実行は 2つの方法でおこなえます:

-   [コードエディター](../code-editor/overview.md) ウィンドウから
-   [メソッド実行](#メソッド実行ダイアログボックスから実行) ダイアログボックスから (プロジェクトメソッドのみ)。

### メソッドエディターからメソッド実行 

[**コードエディター**](../code-editor/overview.md) ウィンドウには、そのエディターで開かれているメソッドを実行するためのボタンがあります。 このボタンに関連付けられているメニューから実行オプションを選択できます:

![](assets/en/concepts/execute-method.png)

このボタンは、プロジェクトメソッドと以下のデータベースメソッドでのみ利用できます:

-   On Startup
-   On Exit
-   On Server Startup
-   On Server Shutdown

以下の実行モードから選択できます:

-   **新規プロセスで実行**: 新規プロセスを作成し、そのプロセス内でメソッドを実行します。
-   **新規プロセスで実行してデバッグ**: 新規プロセスを作成し、デバッガーウィンドウを開いてメソッドを表示します。
-   **アプリケーションプロセスで実行**: アプリケーションプロセス内でメソッドを実行します (アプリケーションプロセス内とは、レコード表示ウィンドウと同じプロセス内ということです)。
-   **アプリケーションプロセスで実行してデバッグ**: アプリケーションプロセス内でデバッガーを開き、メソッドを表示します。

#### メソッド実行ダイアログボックスから実行  

**実行** メニューから **メソッド...** コマンドを選択すると、**メソッド実行** ダイアログボックスが表示されます。

このダイアログボックスには、データベースのプロジェクトメソッド (コンポーネントの共有メソッドを含む) が表示されます。 一方、非表示属性が設定されたプロジェクトメソッドは表示されません。 

プロジェクトメソッドを実行するには、リストからメソッドを選択し、**実行** をクリックします。 デバッグモードでメソッドを実行するには **デバッグ** をクリックします。 デバッガーに関する詳細は、[デバッガー](../Debugging/basics.md) の章を参照ください。 

**4D Serverに関する注記**: サーバー上でメソッドを実行する場合、**デバッグ** オプションは使用できません。

**新規プロセス** チェックボックスを選択すると、選択したメソッドは新規に作成されたプロセス内で実行されます。 大量の印刷など時間のかかる処理をメソッドがおこなう場合でもこのオプションを使用すれば、レコードの追加、グラフの作成などの処理をアプリケーションプロセスで継続できます。 プロセスに関する詳細は 4D *ランゲージリファレンス* マニュアルの [プロセス](https://doc.4d.com/4Dv19R5/4D/19-R5/Processes.300-5830912.ja.html) を参照ください。

**4D Serverに関する注記:**:

-   クライアントではなくサーバー上でメソッドを実行したい場合、実行モードメニューで **4D Server** を選択します。 この場合 *ストアドプロシージャー* と呼ばれるプロセスが新規にサーバー上で作成され、メソッドが実行されます。

   このオプションを使用して、ネットワークトラフィックを減らしたり、4D Serverの動作を最適化したりできます (特にディスクに格納されたデータにアクセスする場合など)。 すべてのタイプのメソッドをサーバー上や他のクライアント上で実行できますが、ユーザーインターフェースを変更するものは例外です。 この場合、ストアドプロシージャーは効果がありません。

-   他のクライアントマシン上でメソッドを実行するよう選択することもできます。 他のクライアントマシンは、事前に登録されていなければメニューに表示されません (詳細は [REGISTER CLIENT](https://doc.4d.com/4Dv19R5/4D/19-R5/REGISTER-CLIENT.301-5830908.ja.html) の説明を参照ください)。

デフォルトでは、**ローカル** オプションが選択されています。 4D シングルユーザーの場合、このオプションしか選択できません。